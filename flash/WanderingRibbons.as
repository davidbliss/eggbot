// Experiment with moving pens randomly, and with flocking tendancies to those that come beforepackage{		import com.davidbliss.eb.Canvas;	import WanderingValue;		import flash.display.Sprite;	import flash.display.Stage;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.KeyboardEvent;		public class WanderingRibbons extends Sprite	{		private var canvas:Canvas;		private var previewCanvas:Canvas;		private var fillLines:Array;		private var baseLine:Array;		private var topLine:Array;		private var bottomLine:Array; 		public function WanderingRibbons()		{				stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;						// draw square to test stage 			var sq:Sprite = new Sprite();			sq.graphics.beginFill( 0xdddddd , 1 );			sq.graphics.drawRect(0,0,stage.stageWidth, stage.stageHeight);			addChild(sq);						// create canvas			canvas = new Canvas(true);			canvas.x=canvas.y=5;			addChild(canvas);						previewCanvas = new Canvas(false);			previewCanvas.x=5;			previewCanvas.y=200;			addChild(previewCanvas);						fillLines = new Array();						// First set the baseline			var wanderX:Number = 0;//Math.round(Math.random()*2000);			var maxX:Number = wanderX+1750+Math.round((Math.random()*500)); // between 2000 and 3000			var minY:Number = 50;			var maxY:Number = 550;			var wanderY:Number = Math.round(Math.random()*maxY);			var maxVelX:Number= 15;			var maxVelY:Number= 5;			var minVelX:Number= 3;			var minVelY:Number= -5;			var velX:Number= Math.round(Math.random()*(maxVelX-minVelX)+minVelX);			var velY:Number= Math.round(Math.random()*(maxVelY-maxVelY)+maxVelY);			var accelX:Number= .4;			var accelY:Number= .4;			var directionAccelX:Number			var directionAccelY:Number			if (Math.random()<.5) {				directionAccelX = 1;			}else {				directionAccelX = -1;			}			if (Math.random()<.5) {				directionAccelY = 1;			}else {				directionAccelY = -1;			}			var probChangeDirectionAccelX:Number= 0;			var probChangeDirectionAccelY:Number= 0;			var probIncrement:Number=.01;						baseLine = new Array();			while (wanderX<maxX){				velX+=(accelX*directionAccelX);				if (Math.random()<probChangeDirectionAccelX) {					directionAccelX*=-1;					probChangeDirectionAccelX = 0;				} else {					probChangeDirectionAccelX += probIncrement;				}				velX=Math.min(velX, maxVelX);				velX=Math.max(velX, minVelX);												if (wanderY>maxY-100 && directionAccelY==1) {					probChangeDirectionAccelY+=.5;					//trace("y too high, probChangeDirectionAccelY:"+probChangeDirectionAccelY);					if (Math.random()<probChangeDirectionAccelY) {						directionAccelY=-1;						probChangeDirectionAccelY = 0;					}				} else if (wanderY<minY+100 && directionAccelY==-1) {					//trace("y too low");					probChangeDirectionAccelY+=.5;					if (Math.random()<probChangeDirectionAccelY) {						directionAccelY=1;						probChangeDirectionAccelY = 0;					}				} else if (Math.random()<probChangeDirectionAccelY) {					//trace("y normal");					directionAccelY*=-1;					probChangeDirectionAccelY = 0;				} else {					probChangeDirectionAccelY += probIncrement;				}												velY+=(accelY*directionAccelY);								velY=Math.min(velY, maxVelY);				velY=Math.max(velY, minVelY);								//trace("Y:"+wanderY+" velY:"+velY+" accelY:"+accelY+" directionAccelY:"+directionAccelY);				wanderY+=Math.round(velY);				wanderX+=Math.round(velX);								var point:Object = new Object();				point.x = wanderX;				point.y = wanderY;				baseLine.push(point);			}			// END Draw baseline									// Draw top and bottom lines			topLine = new Array();			bottomLine = new Array();			var maxLines:Number=30;			var topWanderV:WanderingValue;			var bottomWanderV:WanderingValue;						var maxTopWander:Number = 0;			var maxBottomWander:Number = 0;						topWanderV = new WanderingValue("top");			bottomWanderV = new WanderingValue("bottom");						var convergenceRange= Math.round(baseLine.length/5);						var point:Object;						for (var ii:Number=0; ii<baseLine.length; ii++){				point = new Object();				point.x = baseLine[ii].x;				var wanderingV:Number = topWanderV.getValue()				if (wanderingV>maxTopWander) maxTopWander=wanderingV;				if (ii > baseLine.length-convergenceRange) {					var convergenceMultiple:Number = (baseLine.length-ii) / convergenceRange;					point.y = baseLine[ii].y+(wanderingV*convergenceMultiple);				} else {					point.y = baseLine[ii].y+wanderingV;				}								topLine.push(point);			}			for (var ii:Number=0; ii<baseLine.length; ii++){				point = new Object();				point.x = baseLine[ii].x;				var wanderingV:Number = bottomWanderV.getValue();				if (wanderingV>maxBottomWander) maxBottomWander=wanderingV;				if (ii > baseLine.length-convergenceRange) {					var convergenceMultiple:Number = (baseLine.length-ii) / convergenceRange;					point.y = baseLine[ii].y-(wanderingV*convergenceMultiple);				} else {					point.y = baseLine[ii].y-wanderingV;				}								bottomLine.push(point);			}						var nextFillLine:Array						// fill in the top			for (var i:Number=0; i<Math.round(maxTopWander/3); i++){				nextFillLine = new Array();				for (var ii:Number=0; ii<baseLine.length; ii++){					point = new Object();					point.x = baseLine[ii].x;					point.y = baseLine[ii].y+Math.round(((topLine[ii].y-baseLine[ii].y)*(i/Math.round(maxTopWander/3))));					nextFillLine.push(point);				}				fillLines.push(nextFillLine);			}			// fill in the bottom			for (var i:Number=0; i<Math.round(maxBottomWander/3); i++){				nextFillLine = new Array();				for (var ii:Number=0; ii<baseLine.length; ii++){					point = new Object();					point.x = baseLine[ii].x;					point.y = baseLine[ii].y+Math.round(((bottomLine[ii].y-baseLine[ii].y)*(i/Math.round(maxBottomWander/3))));					nextFillLine.push(point);				}				fillLines.push(nextFillLine);			}						stage.addEventListener(KeyboardEvent.KEY_DOWN, checkKeystroke);						previewLine(topLine, 1)			previewLine(bottomLine, 1)		}				private function previewLine(line:Array, pen:Number):void {			previewCanvas.setPen(pen);			previewCanvas.penUp(true);			previewCanvas.movePen(line[0].x, line[0].y);			previewCanvas.penUp(false);			for (var ii:Number=1; ii<line.length; ii++){				 previewCanvas.movePen(line[ii].x, line[ii].y);			}			previewCanvas.penUp(true);		}				private function drawLine(line:Array, pen:Number):void {			canvas.setPen(pen);			canvas.penUp(true);			canvas.movePen(line[0].x, line[0].y);			canvas.penUp(false);			for (var ii:Number=1; ii<line.length; ii++){				 canvas.movePen(line[ii].x, line[ii].y);			}			canvas.penUp(true);		}				private function checkKeystroke(event:KeyboardEvent):void{			var i:Number = event.charCode-48			trace(i)			if (i==1){				// draw baseline				drawLine(baseLine, 0)								// draw fill lines				for (var i:Number=0; i<fillLines.length; i++){					drawLine(fillLines[i], 0)				}			}			if (i==2){				// draw top				drawLine(topLine, 1)				// draw bottom				drawLine(bottomLine, 1)			}		}	}}