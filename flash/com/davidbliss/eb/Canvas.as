package com.davidbliss.eb{	import SerialPort;		import flash.display.Sprite;	import flash.events.DataEvent;	import flash.events.Event;		public class Canvas extends Sprite	{		private var visualCanvas:Sprite;		private var eggWidth:Number = 2000;		private var eggHeight:Number = 700;		private var isPenUp:Boolean;		private var penX:Number = 0; // range is 0-2000 (bot range is 3200, but we scale by 1.6)		private var penY:Number = 350; // range is 0-600, 350 is middle		private var controller:SerialPort;		private var isConnected:Boolean;		private var pens:Array = new Array(0xFAAE74, 0xEF6000, 0xFC27000, 0xF1F1C1, 0xFAD961, 0xFFFC0C, 0x7797FF, 0x0040C4, 0x003299);				//recommended coordinate system is y=100 - 700; x=0 - 3200		public function Canvas(drawOnEgg:Boolean)		{				isConnected = drawOnEgg;						// draw square to test stage dimenstions			visualCanvas = new Sprite();			visualCanvas.graphics.beginFill( 0xffffff , 1 );			visualCanvas.graphics.drawRect(0,0,(eggWidth*1.6)/4, eggHeight/4);			visualCanvas.graphics.endFill();						visualCanvas.graphics.lineStyle(1, 0x000000);			visualCanvas.graphics.moveTo(penX, penY); 						addChild(visualCanvas);						// conntect to tinker proxy			if (isConnected){				controller = new SerialPort();				controller.addEventListener(DataEvent.DATA, onControllerData );				controller.addEventListener(Event.CONNECT, onConnect );				controller.connect( "127.0.0.1", 5331 );			}		}				public function setPen(p:Number):void {			visualCanvas.graphics.endFill();			visualCanvas.graphics.lineStyle(1, pens[p]);		}				public function onConnect(e:Event):void{			penUp(true);		}				public function penUp(b:Boolean):void{			//trace("penUp:"+b);			isPenUp = b;						if (isConnected){				if (b){					controller.send("SP,1,300\n");					controller.send("SM,300,0,0\n");				} else {					controller.send("SP,0,300\n");					controller.send("SM,300,0,0\n");				}			}			/*			http://www.schmalzhaus.com/EBB/EBBCommands.html			Format: "SP,<value>,<duration><CR>"			<value> is 0 (for up) or 1 (for down)			<duration> (optional parameter - if no value then 500 is used internally) is a value from 1 to 65,535 and is in milliseconds. 			It represents the total length of time between when the pen move is started, and when the next command will be executed. 			Note that this does not have anything to do with how fast the pen moves (which is set with the SC command). 			The <duration> parameter is to force the EBB not to execute the next command (normally an SM) for some length of time, 			which gives the system time to allow the pen move to complete and then some extra time before moving the motors 			(if you set up the pen speed and this duration parameter properly).			*/		}						public function movePen(x:Number, y:Number, t:Boolean=false):void{			// move pen to a certain coordinate						x *= 1.6//14; //adjust for egg shape, otherwise, circles come out as ellipses						// enforce recommended limits (within 20)			// y = Math.max(-20,y);			// y = Math.min(620,y);						x = Math.round(x);			y = Math.round(y);									if (!isPenUp){				//trace("drawing x:"+x+" y:"+y);				visualCanvas.graphics.lineTo(x/4, y/4); //virtual canvas is quarter resolution			} else {				//trace("moving x:"+x+" y:"+y);				visualCanvas.graphics.moveTo(x/4, y/4); //virtual canvas is quarter resolution			}						//test range of motion			// second axis is x; 3200 is full revolution			// first is y, 300 - 360 in either direction of up						var deltaX:Number=x-penX;			var deltaY:Number=penY-y;			var duration:Number = 9*Math.round(Math.pow(Math.max(Math.abs(deltaX), Math.abs(deltaY)),2/3));						var command:String="SM,"+duration+","+deltaY+","+deltaX+"\n"			//trace("movePen");			//if (t) trace("from x:"+penX+", to x:"+x+", delta:"+deltaX);			//if (t) trace("from y:"+penY+", to y:"+y+", delta:"+deltaY);			//trace(command);			if (isConnected) controller.send(command);						//delay			//var command:String="SM,300,0,0\n"			//if (isConnected) controller.send(command);						// For the eggbott, move pen actually moves the servo motors that spin the egg(x) or move the arm holding the pen (y)			/*			http://www.schmalzhaus.com/EBB/EBBCommands.html			Format: "SM,<duration>,<axis1>,<axis2><CR>"			<duration> is a value from 1 to 65,535 and is in milliseconds. It represents the total length of time you want this move to take.			<axis1> and <axis2> are values from -32,767 to +32,767 and represent the number of steps for each motor to take in <duration> milliseconds.			If both <axis1> and <axis2> are zero, then a delay of <duration> ms is executed. <axis2> is an optional value, and if it is not included 			in the command, zero steps are assumed for axis 2.			*/						penX=x;			penY=y;		}				public function movePenBy(x:Number, y:Number, t:Boolean=false):void{			// move pen regardless of space (as a vector)						x *= 1.6//14; //adjust for egg shape, otherwise, circles come out as ellipses						x = Math.round(x);			y = Math.round(y);						if (!isPenUp){				//trace("drawing x:"+x+" y:"+y);				visualCanvas.graphics.lineTo((penX+x)/4, (penY+y)/4); //virtual canvas is quarter resolution			} else {				//trace("moving x:"+x+" y:"+y);				visualCanvas.graphics.moveTo((penX+x)/4, (penY+y)/4); //virtual canvas is quarter resolution			}						x = Math.round(x);			y = Math.round(y);						//var duration:Number = Math.max(Math.abs(x), Math.abs(y))			var duration:Number = 9*Math.round(Math.pow(Math.max(Math.abs(x), Math.abs(y)),2/3));			var command:String="SM,"+duration+","+-y+","+x+"\n"						if (isConnected) controller.send(command);						penX=penX+x;			penY=penY+y;		}				public function DrawCircle(cx:Number, cy:Number, r:Number, num_segments:Number, keepPenDown:Boolean):void{ 			var theta:Number = 2 * Math.PI / num_segments; // angle to rotate for each line						var x1:Number = cx+r			var x2:Number = x1;			var y1:Number = cy;			var y2:Number = y1;						if (!keepPenDown){				penUp(true);			}						movePen(x1, y1);						penUp(false);			//trace("moving pen to start of circle, x:", x1, "y:",y1)			for(var i:Number = 1; i <= num_segments; i++) { 1				x2 = cx+(Math.cos(theta*i)*r);				y2 = cy+(Math.sin(theta*i)*r);				if (i==1) {					//trace("drawing first point, x:", x2, "y:",y2)					movePen(x2, y2, true);				} else if (i==num_segments) {					//trace("drawing last point, x:", x2, "y:",y2)					movePen(x2, y2, true);				} else {					movePen(x2, y2);				}												x1=x2;				y1=y2;			} 			movePen(x1, y1);			if (!keepPenDown) penUp(true);		}				public function drawThickCircle(cx:Number, cy:Number, outerRadius:Number, innerRadius:Number, num_segments:Number):void{ 			//trace("\ndrawFilledCircle");			//trace("center:"+x+","+y+" radius:"+r);						// to prevent calibration problems when moving backward, roll always roll forward			//while (cx+outerRadius < penX/1.6) cx+= 2000;						for(var i:Number = outerRadius; i >= innerRadius; i=i-4) { 1				DrawCircle(cx, cy, i, num_segments, true);			} 			penUp(true);					}				public function DrawFilledCircle(cx:Number, cy:Number, r:Number, num_segments:Number):void{ 			//trace("\ndrawFilledCircle");			//trace("center:"+x+","+y+" radius:"+r);						// to prevent calibration problems when moving backward, roll always roll forward			//while (cx+r < penX/1.6) cx+= 2000;						// CHECK RADIUS SIZE FOR THOSE THAT SHOULD NOT BE DRAWN			if(r!=0){				//penUp(true);				//movePen(cx, cy);				//penUp(false);				for(var i:Number = r; i >= 0; i=i-4) { 1					DrawCircle(cx, cy, i, num_segments, true);				} 				penUp(true);			}		}				public function drawRect(x:Number, y:Number, w:Number, h:Number, keepPenDown:Boolean):void{ 						//trace(x, y, w, h, x+w);			if (!keepPenDown){				penUp(true);			}			movePen(x, y);			penUp(false);						movePen(x+w, y);			movePen(x+w, y+h);			movePen(x, y+h);			movePen(x, y);							if (!keepPenDown) penUp(true);		}				public function drawLine(x:Number, y:Number, x2:Number, y2:Number):void{ 						penUp(true);			movePen(x, y);			penUp(false);			movePen(x2, y2);			penUp(true);		}				public function drawFilledRect(x:Number, y:Number, w:Number, h:Number):void{ 			//trace("------Draw new filled rect------");			var steps:Number = Math.min(w,h)/2;			var stepOffset:Number = 4;						penUp(true);			movePen(x, y);			penUp(false);			for(var i:Number = 0; i<steps; i=i+stepOffset) { 				drawRect(x+(i), y+(i), w-(2*i), h-(2*i), true);			} 			penUp(true);		}				public function drawThickRect(x:Number, y:Number, w:Number, h:Number, f:Boolean):void{ 			//trace("------Draw new filled rect------");			var steps:Number = Math.min(w,h)/2;			if (f) steps=steps/2;			var stepOffset:Number = 4;						penUp(true);			movePen(x, y);			penUp(false);			for(var i:Number = 0; i<steps; i=i+stepOffset) { 				drawRect(x+(i), y+(i), w-(2*i), h-(2*i), true);			} 			penUp(true);		}				private function onControllerData( event:DataEvent ):void {			//trace( "onControllerData", event.data );		}					}}